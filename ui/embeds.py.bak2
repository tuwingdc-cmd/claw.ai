"""
All-in-One Settings UI - FIXED VERSION
"""

import discord
from discord.ui import View, Select, Button, button
from discord import SelectOption, Interaction, Embed
from typing import Dict, Callable, Optional
import logging
import asyncio
import traceback

from config import PROVIDERS, FALLBACK_CHAINS, list_available_providers

log = logging.getLogger(__name__)

# ============================================================
# HELPER: Check grounding model (inline to avoid import issues)
# ============================================================

GROUNDING_MODELS = {
    ("pollinations", "gemini-search"),
    ("pollinations", "perplexity-fast"),
    ("pollinations", "perplexity-reasoning"),
}

def is_grounding_model(provider: str, model: str) -> bool:
    return (provider, model) in GROUNDING_MODELS

# ============================================================
# SETTINGS PANEL EMBED
# ============================================================

def create_settings_panel(
    settings: Dict,
    provider_icons: Dict,
    search_icons: Dict,
    mode_icons: Dict
) -> Embed:

    embed = Embed(title="‚öôÔ∏è Settings", color=discord.Color.blue())
    profiles = settings["profiles"]
    active = settings["active_mode"]

    lines = []
    for mode in ["normal", "reasoning", "search"]:
        p = profiles[mode]
        mi = mode_icons.get(mode, "üì¶")
        pi = provider_icons.get(p["provider"], "üì¶")
        marker = " üìå" if mode == active else ""
        line = f"{mi} **{mode.title()}{marker}** : {pi} `{p['provider']}` ‚Üí `{p['model']}`"
        if mode == "search":
            si = search_icons.get(p.get("engine", "duckduckgo"), "üîç")
            line += f" + {si} `{p.get('engine', 'duckduckgo')}`"
            
            if is_grounding_model(p["provider"], p["model"]):
                line += " *(built-in search)*"
            else:
                line += " *(manual search)*"
        lines.append(line)

    embed.add_field(name="Mode Profiles", value="\n".join(lines), inline=False)

    auto_chat = "üü¢ ON" if settings.get("auto_chat") else "üî¥ OFF"
    auto_detect = "üü¢ ON" if settings.get("auto_detect") else "üî¥ OFF"
    embed.add_field(
        name="Toggles",
        value=f"Auto-detect: {auto_detect}  |  Auto-chat: {auto_chat}",
        inline=False
    )

    embed.add_field(
        name="üîç Search Info",
        value=(
            "**Auto-detect ON** ‚Üí bot otomatis search kalau deteksi pertanyaan real-time\n"
            "**Model grounding** (gemini-search/perplexity) ‚Üí search built-in\n"
            "**Model biasa** ‚Üí DuckDuckGo search + LLM summarize"
        ),
        inline=False
    )

    return embed

# ============================================================
# MODE CONFIG EMBED
# ============================================================

def create_mode_config_embed(mode, profile, mode_icons, provider_icons, search_icons) -> Embed:
    mi = mode_icons.get(mode, "üì¶")
    pi = provider_icons.get(profile["provider"], "üì¶")

    embed = Embed(
        title=f"{mi} Configure {mode.title()}",
        color=discord.Color.blue()
    )

    current = f"{pi} `{profile['provider']}` ‚Üí `{profile['model']}`"
    
    if mode == "search":
        si = search_icons.get(profile.get("engine", "duckduckgo"), "ü¶Ü")
        current += f"\n{si} Search engine: `{profile.get('engine', 'duckduckgo')}`"
        
        if is_grounding_model(profile["provider"], profile["model"]):
            current += "\n‚úÖ **Built-in grounding** ‚Äî search otomatis dari model"
        else:
            current += "\nüîß **Manual search** ‚Äî DuckDuckGo + LLM summarize"

    embed.add_field(name="Current", value=current, inline=False)

    chain = FALLBACK_CHAINS.get(mode, FALLBACK_CHAINS["normal"])
    fb_lines = []
    for i, (prov, model) in enumerate(chain[:5], 1):
        fi = provider_icons.get(prov, "üì¶")
        model_str = model or prov
        fb_lines.append(f"{i}. {fi} `{prov}` ‚Üí `{model_str}`")

    embed.add_field(name="Fallback Chain", value="\n".join(fb_lines), inline=False)

    embed.set_footer(text="Step 1: Pilih Provider ‚Üí Step 2: Pilih Model ‚Üí Save")
    return embed

# ============================================================
# MAIN SETTINGS VIEW
# ============================================================

class SettingsView(View):
    def __init__(self, settings, callback, provider_icons, search_icons, mode_icons, timeout=300):
        super().__init__(timeout=timeout)
        self.settings = settings
        self.callback = callback
        self.pi = provider_icons
        self.si = search_icons
        self.mi = mode_icons

        self.add_item(ModeDropdown(settings, self._on_mode_select, mode_icons, provider_icons))

    async def on_error(self, interaction: Interaction, error: Exception, item):
        log.error(f"SettingsView error: {error}\n{traceback.format_exc()}")
        try:
            await interaction.response.send_message(f"‚ùå Error: {error}", ephemeral=True)
        except:
            pass

    async def _on_mode_select(self, interaction: Interaction, mode: str):
        try:
            self.settings["active_mode"] = mode
            profile = self.settings["profiles"][mode]
            
            embed = create_mode_config_embed(mode, profile, self.mi, self.pi, self.si)
            view = ModeConfigView(self.settings, mode, self.callback, self.mi, self.pi, self.si)
            
            await interaction.response.edit_message(embed=embed, view=view)
        except Exception as e:
            log.error(f"_on_mode_select error: {e}\n{traceback.format_exc()}")
            try:
                await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)
            except:
                pass

    @button(label="Auto-Detect", style=discord.ButtonStyle.secondary, emoji="üîÑ", row=1)
    async def toggle_detect(self, interaction: Interaction, btn: Button):
        try:
            self.settings["auto_detect"] = not self.settings.get("auto_detect", False)
            await self.callback(interaction, "auto_detect", self.settings["auto_detect"])
        except Exception as e:
            log.error(f"toggle_detect error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    @button(label="Auto-Chat", style=discord.ButtonStyle.secondary, emoji="üí¨", row=1)
    async def toggle_chat(self, interaction: Interaction, btn: Button):
        try:
            self.settings["auto_chat"] = not self.settings.get("auto_chat", False)
            await self.callback(interaction, "auto_chat", self.settings["auto_chat"])
        except Exception as e:
            log.error(f"toggle_chat error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    @button(label="Monitor", style=discord.ButtonStyle.success, emoji="üìä", row=1)
    async def monitor(self, interaction: Interaction, btn: Button):
        try:
            available = list_available_providers()
            lines = []
            for name, provider in PROVIDERS.items():
                icon = self.pi.get(name, "üì¶")
                status = "üü¢" if name in available else "‚ö™"
                lines.append(f"{status} {icon} **{provider.name}** ‚Ä¢ `{provider.rate_limit}`")

            embed = Embed(title="üìä Provider Health", description="\n".join(lines), color=discord.Color.blue())
            view = BackToMainView(self.settings, self.callback, self.pi, self.si, self.mi)
            
            await interaction.response.edit_message(embed=embed, view=view)
        except Exception as e:
            log.error(f"monitor error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    @button(label="Reset", style=discord.ButtonStyle.danger, emoji="üîÑ", row=1)
    async def reset(self, interaction: Interaction, btn: Button):
        try:
            await self.callback(interaction, "reset", True)
        except Exception as e:
            log.error(f"reset error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

# ============================================================
# MODE DROPDOWN
# ============================================================

class ModeDropdown(Select):
    def __init__(self, settings, callback, mode_icons, provider_icons):
        self.cb = callback
        active = settings.get("active_mode", "normal")
        profiles = settings.get("profiles", {})

        options = []
        for mode_key, label, emoji in [
            ("normal", "Normal Chat", "üí¨"),
            ("reasoning", "Reasoning", "üß†"),
            ("search", "Search", "üîç"),
        ]:
            p = profiles.get(mode_key, {})
            pi = provider_icons.get(p.get("provider", ""), "")
            current_info = f"Now: {pi} {p.get('provider', '?')}/{p.get('model', '?')}"
            
            options.append(SelectOption(
                label=label,
                value=mode_key,
                emoji=emoji,
                description=current_info[:100],
                default=mode_key == active
            ))

        super().__init__(placeholder="Pilih mode untuk dikonfigurasi...", options=options, row=0)

    async def callback(self, interaction: Interaction):
        try:
            await self.cb(interaction, self.values[0])
        except Exception as e:
            log.error(f"ModeDropdown callback error: {e}\n{traceback.format_exc()}")
            try:
                await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)
            except:
                pass

# ============================================================
# MODE CONFIG VIEW
# ============================================================

class ModeConfigView(View):
    def __init__(self, settings, mode, callback, mode_icons, provider_icons, search_icons, timeout=300):
        super().__init__(timeout=timeout)
        self.settings = settings
        self.mode = mode
        self.cb = callback
        self.mi = mode_icons
        self.pi = provider_icons
        self.si = search_icons
        
        self._selected_provider = settings["profiles"][mode]["provider"]
        self._selected_model = settings["profiles"][mode]["model"]

        self.add_item(ProviderDropdown(settings, mode, provider_icons, self._on_provider_select))
        self.add_item(ModelDropdown(self._selected_provider, self._selected_model, mode, self._on_model_select))

    async def on_error(self, interaction: Interaction, error: Exception, item):
        log.error(f"ModeConfigView error: {error}\n{traceback.format_exc()}")
        try:
            await interaction.response.send_message(f"‚ùå Error: {error}", ephemeral=True)
        except:
            pass

    async def _on_provider_select(self, interaction: Interaction, provider_name: str):
        try:
            self._selected_provider = provider_name
            
            provider = PROVIDERS.get(provider_name)
            if provider and provider.models:
                for m in provider.models:
                    if self.mode in m.modes:
                        self._selected_model = m.id
                        break
                else:
                    self._selected_model = provider.models[0].id

            self.settings["profiles"][self.mode]["provider"] = provider_name
            self.settings["profiles"][self.mode]["model"] = self._selected_model

            profile = self.settings["profiles"][self.mode]
            embed = create_mode_config_embed(self.mode, profile, self.mi, self.pi, self.si)
            view = ModeConfigView(self.settings, self.mode, self.cb, self.mi, self.pi, self.si)
            
            await interaction.response.edit_message(embed=embed, view=view)
        except Exception as e:
            log.error(f"_on_provider_select error: {e}\n{traceback.format_exc()}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    async def _on_model_select(self, interaction: Interaction, model_id: str):
        try:
            self._selected_model = model_id
            self.settings["profiles"][self.mode]["model"] = model_id

            profile = self.settings["profiles"][self.mode]
            embed = create_mode_config_embed(self.mode, profile, self.mi, self.pi, self.si)
            view = ModeConfigView(self.settings, self.mode, self.cb, self.mi, self.pi, self.si)
            
            await interaction.response.edit_message(embed=embed, view=view)
        except Exception as e:
            log.error(f"_on_model_select error: {e}\n{traceback.format_exc()}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    @button(label="Save", style=discord.ButtonStyle.success, emoji="‚úÖ", row=2)
    async def save_btn(self, interaction: Interaction, btn: Button):
        try:
            value = {
                "mode": self.mode,
                "provider": self._selected_provider,
                "model": self._selected_model,
            }
            if self.mode == "search":
                value["engine"] = self.settings["profiles"]["search"].get("engine", "duckduckgo")
            await self.cb(interaction, "save_profile", value)
        except Exception as e:
            log.error(f"save_btn error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

    @button(label="Test", style=discord.ButtonStyle.primary, emoji="üß™", row=2)
    async def test_btn(self, interaction: Interaction, btn: Button):
        try:
            await interaction.response.defer()
            
            from core.providers import ProviderFactory
            from config import API_KEYS

            provider = ProviderFactory.get(self._selected_provider, API_KEYS)
            icon = self.pi.get(self._selected_provider, "üì¶")
            
            embed = create_mode_config_embed(
                self.mode, self.settings["profiles"][self.mode],
                self.mi, self.pi, self.si
            )
            
            if not provider:
                embed.set_footer(text=f"‚ùå {icon} {self._selected_provider}: no API key")
                view = ModeConfigView(self.settings, self.mode, self.cb, self.mi, self.pi, self.si)
                await interaction.edit_original_response(embed=embed, view=view)
                return

            messages = [{"role": "user", "content": "Say OK"}]
            
            try:
                result = await asyncio.wait_for(
                    provider.chat(messages, self._selected_model, max_tokens=10),
                    timeout=30.0
                )
                
                if result.success:
                    embed.set_footer(text=f"‚úÖ OK: {icon} {self._selected_provider}/{self._selected_model} ({result.latency:.1f}s)")
                else:
                    embed.set_footer(text=f"‚ùå Failed: {str(result.error)[:50]}")
            except asyncio.TimeoutError:
                embed.set_footer(text=f"‚è±Ô∏è Timeout (>30s)")
            except Exception as e:
                embed.set_footer(text=f"‚ùå Error: {str(e)[:50]}")

            view = ModeConfigView(self.settings, self.mode, self.cb, self.mi, self.pi, self.si)
            await interaction.edit_original_response(embed=embed, view=view)
            
        except Exception as e:
            log.error(f"test_btn error: {e}\n{traceback.format_exc()}")
            try:
                await interaction.followup.send(f"‚ùå Error: {e}", ephemeral=True)
            except:
                pass

    @button(label="Back", style=discord.ButtonStyle.secondary, emoji="‚óÄÔ∏è", row=2)
    async def back_btn(self, interaction: Interaction, btn: Button):
        try:
            await self.cb(interaction, "back", None)
        except Exception as e:
            log.error(f"back_btn error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

# ============================================================
# PROVIDER DROPDOWN
# ============================================================

class ProviderDropdown(Select):
    def __init__(self, settings, mode, provider_icons, callback):
        self.cb = callback
        current = settings["profiles"][mode]["provider"]
        available = list_available_providers()

        options = []
        for name, provider in PROVIDERS.items():
            icon = provider_icons.get(name, "üì¶")
            status = "‚úì" if name in available else "‚úó"
            mode_models = [m for m in provider.models if mode in m.modes]
            desc = f"{status} ‚Ä¢ {len(mode_models)}/{len(provider.models)} models"

            options.append(SelectOption(
                label=provider.name,
                value=name,
                description=desc[:100],
                emoji=icon,
                default=name == current
            ))

        super().__init__(placeholder="Step 1: Pilih Provider", options=options[:25], row=0)

    async def callback(self, interaction: Interaction):
        try:
            await self.cb(interaction, self.values[0])
        except Exception as e:
            log.error(f"ProviderDropdown error: {e}\n{traceback.format_exc()}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

# ============================================================
# MODEL DROPDOWN
# ============================================================

class ModelDropdown(Select):
    def __init__(self, provider_name, current_model, mode, callback):
        self.cb = callback
        provider = PROVIDERS.get(provider_name)
        options = []

        if provider:
            mode_models = [m for m in provider.models if mode in m.modes]
            other_models = [m for m in provider.models if mode not in m.modes]
            
            for model in mode_models:
                options.append(SelectOption(
                    label=f"‚òÖ {model.name}"[:100],
                    value=model.id,
                    description=model.id[:100],
                    default=model.id == current_model
                ))

            for model in other_models:
                options.append(SelectOption(
                    label=model.name[:100],
                    value=model.id,
                    description=model.id[:100],
                    default=model.id == current_model
                ))

        if not options:
            options.append(SelectOption(label="No models", value="none"))

        super().__init__(placeholder="Step 2: Pilih Model", options=options[:25], row=1)

    async def callback(self, interaction: Interaction):
        try:
            if self.values[0] != "none":
                await self.cb(interaction, self.values[0])
            else:
                await interaction.response.defer()
        except Exception as e:
            log.error(f"ModelDropdown error: {e}\n{traceback.format_exc()}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

# ============================================================
# BACK TO MAIN VIEW
# ============================================================

class BackToMainView(View):
    def __init__(self, settings, callback, pi, si, mi, timeout=120):
        super().__init__(timeout=timeout)
        self.settings = settings
        self.cb = callback
        self.pi = pi
        self.si = si
        self.mi = mi

    @button(label="Back", style=discord.ButtonStyle.secondary, emoji="‚óÄÔ∏è")
    async def back(self, interaction: Interaction, btn: Button):
        try:
            await self.cb(interaction, "back", None)
        except Exception as e:
            log.error(f"BackToMainView error: {e}")
            await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)
